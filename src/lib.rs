use pest_meta::ast::{Expr, RuleType};
use pest_meta::parser;
use quote::{format_ident, quote};

#[proc_macro_derive(TypedRules, attributes(typed_mod))]
pub fn derive_macro(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let ast: syn::DeriveInput = syn::parse2(input.into()).unwrap();
    let grammar = get_attribute(&ast, "grammar");
    let grammar_inline = get_attribute(&ast, "grammar_inline");
    let module_name = get_attribute(&ast, "typed_mod").unwrap_or("typed".into());

    let (filename, source) =
        match (grammar, grammar_inline) {
            (_, Some(source)) => ("inline grammar".to_string(), source),
            (Some(filename), _) => {
                let root = std::env::var("CARGO_MANIFEST_DIR").unwrap_or_default();
                let path = std::path::Path::new(&root).join(&filename);
                let source = std::fs::read_to_string(path.clone())
                    .map_err(|e| format!("opening {path:?}: {e}"))
                    .unwrap();
                (filename, source)
            }
            (None, None) => return quote! {
                compile_error!(r#"need #[grammar = "..."] or #[grammar_inline = "..."] attribute"#);
            }
            .into(),
        };

    let module_name = format_ident!("{}", module_name);
    let module_comment = format!(" Typed rules generated by pestle from `{filename}`",);
    let tree = parser::parse(parser::Rule::grammar_rules, &source).unwrap();
    let rules = parser::consume_rules(tree).unwrap();

    // Avoid generating structs or fields for silent rules.
    // Also drop "SOI" and "EOI" if they appear in a rule.
    let mut skip: std::collections::HashSet<&str> = ["SOI", "EOI"].into();
    for rule in &rules {
        if rule.ty == RuleType::Silent {
            skip.insert(rule.name.as_str());
        }
    }

    let preamble = quote! {
        use super::Rule;
        use bumpalo::collections::Vec;
        use bumpalo::Bump;
        use pest::iterators::Pair;
        use pest::Span;

        pub trait TypedRule<'i> {
            const RULE: Rule;
            fn span(&self) -> &Span<'i>;
        }

        fn to_singleton<T>(mut v: Vec<T>) -> T {
            match v.len() {
                1 => v.pop().unwrap(),
                n => panic!("expected exactly one item, got {n}"),
            }
        }

        fn to_option<T>(mut v: Vec<T>) -> Option<T> {
            match v.len() {
                0 => None,
                1 => v.pop(),
                n => panic!("expected at most one item, got {n}"),
            }
        }
    };

    let mut defs = vec![];
    for rule in &rules {
        let name = rule.name.as_str();
        if skip.contains(&name) {
            continue;
        }
        let name = format_ident!("{}", name);
        let expr = &rule.expr;
        let (doc_comment, struct_def, span_body, build_body);
        if matches!(rule.ty, RuleType::Atomic) || matches!(expr, Expr::Str(_)) {
            doc_comment = format!(" atomic rule `{name} = {expr}`");
            struct_def = quote! { pub struct #name<'i>(Span<'i>); };
            span_body = quote! { &self.0 };
            build_body = quote! { alloc.alloc(Self(pair.as_span())) };
        } else if let Some(v) = choice_items(&expr) {
            let v = v
                .into_iter()
                .map(|ty| format_ident!("{}", ty))
                .collect::<Vec<_>>();
            doc_comment = format!(" enum rule `{name} = {expr}`");
            struct_def = quote! {
                pub enum #name<'i> {
                    #( #v(&'i #v<'i>), )*
                }
            };
            span_body = quote! {
                match self {
                    #( Self::#v(x) => x.span(), )*
                }
            };
            build_body = quote! {
                let inner = pair.into_inner().next().unwrap();
                alloc.alloc(match inner.as_rule() {
                    #( Rule::#v => #name::#v(#v::build(inner, alloc)), )*
                    rule => panic!("unexpected rule {rule:?} within {:?}", Self::RULE),
                })
            };
        } else {
            doc_comment = format!(" sequence rule `{name} = {expr}`");
            let f = sequence_items(&expr)
                .into_iter()
                .filter(|item| !skip.contains(&item.0.as_str()))
                .map(|(ty, rep)| {
                    let id = format_ident!("{}", snake_case(&ty));
                    let tmp_id = format_ident!("_tmp_{id}");
                    let ty = format_ident!("{ty}");
                    (ty, id, tmp_id, rep)
                })
                .collect::<Vec<_>>();
            let ty = f.iter().map(|(ty, _, _, _)| ty).collect::<Vec<_>>();
            let tmp_id = f.iter().map(|(_, _, tmp_id, _)| tmp_id).collect::<Vec<_>>();
            let fields = f.iter().map(|(ty, id, _, rep)| match rep {
                1 => quote! { pub #id: &'i #ty<'i>, },
                0 => quote! { pub #id: Option<&'i #ty<'i>>, },
                _ => quote! { pub #id: &'i [&'i #ty<'i>], },
            });
            let init = f.iter().map(|(_, id, tmp_id, rep)| match rep {
                1 => quote! { #id: to_singleton(#tmp_id), },
                0 => quote! { #id: to_option(#tmp_id), },
                _ => quote! { #id: alloc.alloc(#tmp_id), },
            });
            struct_def = quote! {
                pub struct #name<'i> {
                    pub _span: Span<'i>,
                    #(#fields)*
                }
            };
            span_body = quote! { &self._span };
            build_body = quote! {
                let _span = pair.as_span();
                #( let mut #tmp_id = Vec::<&'i #ty>::new_in(alloc); )*
                for child in pair.into_inner() {
                    match child.as_rule() {
                        #( Rule::#ty => #tmp_id.push(#ty::build(child, alloc)), )*
                        _ => (),
                    }
                }
                alloc.alloc(Self {
                    _span,
                    #(#init)*
                })
            };
        }

        let def = quote! {
            #[doc = #doc_comment]
            #[derive(Clone, Debug, Eq, PartialEq)]
            #struct_def
            impl<'i> TypedRule<'i> for #name<'i> {
                const RULE: Rule = Rule::#name;
                fn span(&self) -> &Span<'i> {
                    #span_body
                }
            }
            impl<'i> #name<'i> {
                pub fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {
                    assert_eq!(Self::RULE, pair.as_rule());
                    #build_body
                }
            }
        };
        defs.push(def);
    }

    let code = quote! {
        pub mod #module_name {
            #![doc = #module_comment]
            #preamble
            #(#defs)*
        }
    };

    code.into()
}

fn get_attribute(ast: &syn::DeriveInput, name: &str) -> Option<String> {
    for attr in &ast.attrs {
        if attr.meta.path().is_ident(name) {
            use syn::*;
            if let Meta::NameValue(MetaNameValue {
                value:
                    Expr::Lit(ExprLit {
                        lit: Lit::Str(string),
                        ..
                    }),
                ..
            }) = &attr.meta
            {
                return Some(string.value());
            }
        }
    }
    None
}

fn choice_items(expr: &Expr) -> Option<Vec<&str>> {
    use core::borrow::Borrow;
    match expr {
        Expr::Choice(a, b) => {
            let mut r = vec![];
            for c in [a.borrow(), b.borrow()] {
                match c {
                    Expr::Ident(n) => r.push(n.as_str()),
                    Expr::Choice(..) => r.extend(choice_items(a)?),
                    _ => panic!(
                        "choices must be in dedicated rules (to guide enum variant names): {c:?}"
                    ),
                }
            }
            assert!(r.len() > 1);
            Some(r)
        }
        _ => None,
    }
}

fn sequence_items(expr: &Expr) -> Vec<(String, usize)> {
    type H = Vec<(String, usize)>;
    fn both(mut a: H, b: H) -> H {
        for (n, i) in b {
            if let Some(x) = a.iter_mut().find(|x| x.0 == n) {
                x.1 = 2;
            } else {
                a.push((n, i));
            }
        }
        a
    }
    fn optional(mut a: H) -> H {
        for (_, i) in &mut a {
            *i &= 2; // reduce 1 to 0
        }
        a
    }
    fn repeated(mut a: H) -> H {
        for (_, i) in &mut a {
            *i = 2;
        }
        a
    }
    match expr {
        Expr::Str(_) => vec![],
        Expr::Insens(_) => vec![],
        Expr::Range(..) => vec![],
        Expr::Ident(n) => vec![(n.clone(), 1)],
        Expr::PeekSlice(..) => vec![],
        Expr::PosPred(_) => vec![],
        Expr::NegPred(_) => vec![],
        Expr::Seq(a, b) => both(sequence_items(a), sequence_items(b)),
        Expr::Choice(..) => {
            panic!("choices must be in dedicated rules (to guide enum variant names): {expr:?}")
        }
        Expr::Opt(e) => optional(sequence_items(e)),
        Expr::Rep(e) => repeated(sequence_items(e)),
        Expr::RepOnce(e) => repeated(sequence_items(e)),
        Expr::RepExact(e, _) => repeated(sequence_items(e)),
        Expr::RepMin(e, _) => repeated(sequence_items(e)),
        Expr::RepMax(e, _) => repeated(sequence_items(e)),
        Expr::RepMinMax(e, _, _) => repeated(sequence_items(e)),
        Expr::Skip(_) => vec![],
        Expr::Push(e) => sequence_items(e),
    }
}

fn snake_case(s: &str) -> String {
    let mut r = String::new();
    let mut last_upper = true;
    for c in s.chars() {
        if c.is_ascii_uppercase() && !last_upper {
            r.push('_');
        }
        last_upper = c.is_ascii_uppercase();
        r.push(c.to_ascii_lowercase());
    }
    r
}
