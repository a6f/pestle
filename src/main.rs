use pest_meta::ast::{Expr, RuleType};
use pest_meta::parser::{consume_rules, parse, Rule};

// TODO: maybe interpolation would be easier with syn

fn main() {
    let filename = std::env::args().nth(1).unwrap();
    let source = std::fs::read_to_string(filename.clone()).unwrap();
    let tree = parse(Rule::grammar_rules, &source).unwrap();
    let rules = consume_rules(tree).unwrap();

    println! {
r##"//! Typed grammar generated by pestle from {filename}

use super::Rule;
use bumpalo::collections::Vec;
use bumpalo::Bump;
use pest::iterators::Pair;
use pest::Span;

pub trait TypedRule<'i> {{
    const UNTYPED_RULE: Rule;
    fn span(&self) -> &Span<'i>;
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self;
}}

fn to_singleton<T>(mut v: Vec<T>) -> T {{
    match v.len() {{
        1 => v.pop().unwrap(),
        n => panic!("expected exactly one item, got {{n}}"),
    }}
}}

fn to_option<T>(mut v: Vec<T>) -> Option<T> {{
    match v.len() {{
        0 => None,
        1 => v.pop(),
        n => panic!("expected at most one item, got {{n}}"),
    }}
}}"##};

    // TODO: build this with two passes
    let mut skip = vec!["SOI", "EOI"];

    for rule in &rules {
        println!();
        let name = rule.name.as_str();
        if skip.contains(&name) {
            continue;
        }
        if rule.ty == RuleType::Silent {
            println!("// silent rule {name} generates no code");
            continue;
        }
        if matches!(rule.ty, RuleType::Atomic) || matches!(rule.expr, Expr::Str(_)) {
            println! {r##"/// atomic rule {name}
#[derive(Debug)]
pub struct {name}<'i>(Span<'i>);

impl<'i> TypedRule<'i> for {name}<'i> {{
    const UNTYPED_RULE: Rule = Rule::{name};
    fn span(&self) -> &Span<'i> {{
        &self.0
    }}
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {{
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        alloc.alloc(Self(pair.as_span()))
    }}
}}"##};
        } else if let Some(f) = choice_items(&rule.expr) {
            if name == "PESTLE_SKIP" {
                // TODO: unique here
                skip.extend(f);
                println!("// applied {name}");
                continue;
            }
            println! {r##"/// enum rule {name}
#[derive(Debug)]
pub enum {name}<'i> {{"##};
            for v in &f {
                println!("    {v}(&'i {v}<'i>),");
            }
            println! {r##"}}

impl<'i> TypedRule<'i> for {name}<'i> {{
    const UNTYPED_RULE: Rule = Rule::{name};
    fn span(&self) -> &Span<'i> {{
        match self {{"##};
            for v in &f {
                println!("            Self::{v}(x) => x.span(),");
            }
            println! {
r##"        }}
    }}
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {{
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let inner = pair.into_inner().next().unwrap();
        alloc.alloc(match inner.as_rule() {{"##};
            for v in &f {
                println!("            Rule::{v} => {name}::{v}({v}::build(inner, alloc)),");
            }
            println! {r##"            rule => panic!("unexpected rule {{rule:?}} within {{:?}}", Self::UNTYPED_RULE),
        }})
    }}
}}"##};
        } else {
            let f = sequence_items(&rule.expr)
                .into_iter()
                .filter(|item| !skip.contains(&item.0.as_str()))
                .map(|(name, rep)| (name.to_ascii_lowercase(), name, rep))
                .collect::<Vec<_>>();
            println! {r##"/// sequence rule {name}
#[derive(Debug)]
pub struct {name}<'i> {{
    pub _span: Span<'i>,"##};
            for (id, ty, rep) in &f {
                match rep {
                    1 => println!("    pub {id}: &'i {ty}<'i>,"),
                    0 => println!("    pub {id}: Option<&'i {ty}<'i>>,"),
                    _ => println!("    pub {id}: &'i Vec<'i, &'i {ty}<'i>>,"),
                };
            }
            println! {r##"}}

impl<'i> TypedRule<'i> for {name}<'i> {{
    const UNTYPED_RULE: Rule = Rule::{name};
    fn span(&self) -> &Span<'i> {{
        &self._span
    }}
    fn build(pair: Pair<'i, Rule>, alloc: &'i Bump) -> &'i Self {{
        assert_eq!(Self::UNTYPED_RULE, pair.as_rule());
        let _span = pair.as_span();"##};
            for (id, ty, _rep) in &f {
                println!("        let mut _tmp_{id} = Vec::<&'i {ty}>::new_in(alloc);");
            }
            println! {r##"
        for child in pair.into_inner() {{
            match child.as_rule() {{"##};
            for (id, ty, _rep) in &f {
                println! {"                Rule::{ty} => _tmp_{id}.push({ty}::build(child, alloc)),"};
            }
            for ty in &skip {
                if *ty != "SOI" {
                    println!("                Rule::{ty} => (),");
                }
            }
            // would be simpler to do nothing here; no need to match skipped rules then
            println! {r##"                rule => panic!("unexpected rule {{rule:?}} within {{:?}}", Self::UNTYPED_RULE),
            }}
        }}
        alloc.alloc(Self {{
            _span,"##};
            for (id, _ty, rep) in &f {
                match rep {
                    1 => println!("            {id}: to_singleton(_tmp_{id}),"),
                    0 => println!("            {id}: to_option(_tmp_{id}),"),
                    _ => println!("            {id}: alloc.alloc(_tmp_{id}),"),
                }
            }
            println! {
r##"        }})
    }}
}}"##};
        }
    }
}

fn choice_items(expr: &Expr) -> Option<Vec<&str>> {
    use core::borrow::Borrow;
    match expr {
        Expr::Choice(a, b) => {
            let mut r = vec![];
            for c in [a.borrow(), b.borrow()] {
                match c {
                    Expr::Ident(n) => r.push(n.as_str()),
                    Expr::Choice(..) => r.extend(choice_items(a)?),
                    _ => panic!(
                        "choices must be in dedicated rules (to guide enum variant names): {c:?}"
                    ),
                }
            }
            assert!(r.len() > 1);
            Some(r)
        }
        _ => None,
    }
}

fn sequence_items(expr: &Expr) -> Vec<(String, usize)> {
    type H = Vec<(String, usize)>;
    fn both(mut a: H, b: H) -> H {
        for (n, i) in b {
            if let Some(x) = a.iter_mut().find(|x| x.0 == n) {
                x.1 = 2;
            } else {
                a.push((n, i));
            }
        }
        a
    }
    fn optional(mut a: H) -> H {
        for (_, i) in &mut a {
            *i &= 2; // reduce 1 to 0
        }
        a
    }
    fn repeated(mut a: H) -> H {
        for (_, i) in &mut a {
            *i = 2;
        }
        a
    }
    match expr {
        Expr::Ident(n) => vec![(n.clone(), 1)],
        Expr::Seq(a, b) => both(sequence_items(a), sequence_items(b)),
        Expr::Choice(..) => {
            panic!("choices must be in dedicated rules (to guide enum variant names): {expr:?}")
        }
        Expr::Opt(e) => optional(sequence_items(e)),
        Expr::Rep(e) => repeated(sequence_items(e)),
        e => unimplemented!("can't handle grammar expression {e:?}"),
    }
}
